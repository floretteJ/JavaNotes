# 项目实现

![image-20210913001858596](D:\Typora\imgs\image-20210913001858596.png)

![image-20210913002013352](D:\Typora\imgs\image-20210913002013352.png)

![image-20210913002058177](D:\Typora\imgs\image-20210913002058177.png)

![image-20210913002124474](D:\Typora\imgs\image-20210913002124474.png)

![image-20210913002227349](D:\Typora\imgs\image-20210913002227349.png)

![image-20210913002312397](D:\Typora\imgs\image-20210913002312397.png)

![image-20210913002413734](D:\Typora\imgs\image-20210913002413734.png)

![image-20210913003307269](D:/Typora/imgs/image-20210913003307269.png)

![image-20210913003431626](D:/Typora/imgs/image-20210913003431626.png)

![image-20210913003510138](D:/Typora/imgs/image-20210913003510138.png)

![image-20210913003629677](D:/Typora/imgs/image-20210913003629677.png)

![image-20210913003646174](D:/Typora/imgs/image-20210913003646174.png)

![image-20210913004259006](D:/Typora/imgs/image-20210913004259006.png)

# 用户注册

![image-20210913004938544](D:/Typora/imgs/image-20210913004938544.png)

![image-20210913005108662](D:/Typora/imgs/image-20210913005108662.png)

![image-20210913005121151](D:/Typora/imgs/image-20210913005121151.png)

![image-20210913005020934](D:/Typora/imgs/image-20210913005020934.png)

![image-20210913005038055](D:/Typora/imgs/image-20210913005038055.png)

![image-20210913005537720](D:/Typora/imgs/image-20210913005537720.png)

![image-20210913010347920](D:/Typora/imgs/image-20210913010347920.png)

![image-20210913011044168](D:/Typora/imgs/image-20210913011044168.png)

![image-20210913012817940](D:/Typora/imgs/image-20210913012817940.png)

![image-20210913012835002](D:/Typora/imgs/image-20210913012835002.png)

# 如何看待面向对象的封装性和反射机制

```java
反射机制与面向对象中的封装性是不是矛盾的？如何看待这两个技术？

这两者并不矛盾。封装性相当于是建议其他类去调用当前类的公共方法，而私有方法不建议去调用，因为公共的方法可能比私有的方法更好，公共方法里面可能添加了一些逻辑。如果非要调用私有的方法，也可以调用，那我们就通过反射的方式去调用。

封装性：其主要体现是将属性和方法设置为私有的使其在其他类中调用时无法访问该类中内部的私有属性和私有方法，隐藏了内部的细节，保证了代码的安全性。如果我们要想使用其私有属性和私有方法则应该使用该类内部的public方法进行调用。

反射：指的是我们在程序运行期间可以借助于反射的API获取任意对象的属性和方法，并且能够操作任意类的属性和方法。这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 反射最大的特点就是动态性。 而反射解决的是能不能调用的问题，它可以调用私有方法，但是通常我们不建议调用。

通过直接new的方式和反射的方式都可以调用公用的结构，那么我们在开发中用哪个？

建议用new的方式（编译的时候就确定了要初始化的对象）。
什么时候用反射的方式：反射的特征：动态性。不确定要去new那个对象就可以用反射的方式。

```



# 反射的应用场景

```java
1、JDBC 的数据库的连接：使用CLASS 类加载驱动程序
2、Spring 框架的使用
    Spring 通过 XML 配置模式装载 Bean 的过程：
        将程序内所有 XML 或 Properties 配置文件加载入内存中
        Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
        使用反射机制，根据这个字符串获得某个类的Class实例
        动态配置实例的属性
        Spring这样做的好处是：
            不用每一次都要在代码里面去new或者做其他的事情
            以后要改的话直接改配置文件，代码维护起来就很方便了
            有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现
3、逆向代码 ，例如反编译
4、与注解相结合的框架 例如Retrofit
5、单纯的反射机制应用框架 例如EventBus 2.x
6、动态生成类框架 例如Gson
```

# B和B+树的底层实现